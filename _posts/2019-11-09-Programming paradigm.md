---
layout: post
title: Programming Paradigm
categories : [ML,DL]
use_math: true
---
Prgramming Paradigm
================
by 알고리즘 문제 해결 전략

1. 단순한 문제로 만들고 최적화 시켜 나간다.

Type of Problems 
------------
- 원하는 답이 존재하는가?
- 여러 답 중 최적의 답 찾기(최적화 문제)


Brute Force
----------------   
완전 탐색 exhaustive search 라고도 한다. 가장 단순한 방법. 모든 경우의 수를 직접 컴퓨터로 돌려보고 그 결과를 찾는 방법이다.
무식해보이지만 컴퓨터는 반복연산에 강점이 있어 별다른 제약이 없는 경우 이 방법으로 대부분의 문제를 풀 수 있다.
실제 상업용 프로그램이나 대회에서는 메모리, 연산량, 연산시간 등에서 제한이 있는 경우가 많지만
제한이 미미한 경우 그냥 사용하기도 한다.
장점은 쉽고 단순하다는 것. 제약조건을 잘 따져본 후 가능하다면 brute force 방법을 쓴다면 많은 노력을 아낄 수 있다.
재귀호출으로 쉽게 구현할 수 있는 경우가 많다.

Divide & Conquer
---------------
분할정복. 주어진 문제를 둘 이상의 부분문제로 분해한 후 각 부분문제를 재귀호출로 계산한다. 각 부분문제의 답이 나오면 이를 이용하여
전체 문제의 답을 계산한다. 재귀 호출과 유사하나 하나의 재귀함수를 찾는 대신 여러 부분문제(거의 절반 정도의)로 분해한다는 점이 다르다.

조건 
1. 문제를 부분문제로 나눌 수 있는 자연스러운 방법이 있다.
2. 부분문제의 답들로 전체문제의 답을 계산하는 효율적인 방법이 있다.

주의점
잘못 분할할 경우 전체 과정에서 여러번 중복계산되는 부분 문제들이 나올 수 있다. 이는 전체 성능을 저하시킨다.
이 경우 Dynamic programming을 사용한다.

Dynamic Programming
---------------
중복계산되는 부분문제는 분할정복을 할 때 부분문제를 계산할 때 나타나는 중복되어 계산되는 부분문제이다. 중복계산되는 부분문제는 분할의 횟수가 늘어날수록 지수적으로 증가한다. 대표적인 문제로 이항계수 계산이 있다.
DP는 분할정복과 비슷한 패러다임이지만 중복계산되는 부분문제(Overlapping subproblems)를 메모리에 저장해서 중복계산에 드는계산자원을 줄이는 방법이다.(계산량이 줄어드는 대신 메모리 사용량이 늘어난다) 
이렇게 값을 저장해뒀다 재사용하는 방법을 memoization이라고 부른다. memoization은 입력에만 출력이 결정되는 referential transparent function에만 적용할 수 있다. 입력 외의 요소가 결과에 영향을 주는 함수는 사용할 수 없다.

DP의 첫단계는 문제를 재귀적으로 해결하는 완전 탐색 알고리즘을 만드는 것이다. 그리고 중복되는 부분들이 많다면 memoization을 적용한다.
특히 전체 답의 개수는 많지만 재귀함수에 주어질 수 있는 입력의 개수가 적을 경우 DP를 사용하는 것이 효과적이다.

DP는 최적화 문제를 풀기위해 제안되었다. 최적화문제에서 유용하게 쓸 수 있다.(다른 문제들에서도 일부 유용하게 쓸 수 있음)

최적 부분 구조(optimal substructure)
현재 부분 문제가 어떤 경로로 호출되었던간에 남은 부분 문제들을 항상 최적으로 풀어도 되는 구조.
각 부분문제의 최적해를 얻었을 때 전체 문제의 최적해를 얻을 수 있을 경우 성립.
ex) 서울부터 대전을 지나 부산까지 가는 최적 경로 = 서울-대전의 최적경로 + 대전-부산의 최적 경로

