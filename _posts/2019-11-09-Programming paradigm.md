---
layout: post
title: Programming Paradigm
categories : [ML,DL]
use_math: true
---
Prgramming Paradigm
================
by 알고리즘 문제 해결 전략

1. 단순한 문제로 만들고 최적화 시켜 나간다.

Type of Problems 
------------
- 원하는 답이 존재하는가?
- 여러 답 중 최적의 답 찾기(최적화 문제)


Brute Force
----------------   
완전 탐색 exhaustive search 라고도 한다. 가장 단순한 방법. 모든 경우의 수를 직접 컴퓨터로 돌려보고 그 결과를 찾는 방법이다.
무식해보이지만 컴퓨터는 반복연산에 강점이 있어 별다른 제약이 없는 경우 이 방법으로 대부분의 문제를 풀 수 있다.
실제 상업용 프로그램이나 대회에서는 메모리, 연산량, 연산시간 등에서 제한이 있는 경우가 많지만
제한이 미미한 경우 그냥 사용하기도 한다.
장점은 쉽고 단순하다는 것. 제약조건을 잘 따져본 후 가능하다면 brute force 방법을 쓴다면 많은 노력을 아낄 수 있다.
재귀호출으로 쉽게 구현할 수 있는 경우가 많다.

Divide & Conquer
---------------
분할정복. 주어진 문제를 둘 이상의 부분문제로 분해한 후 각 부분문제를 재귀호출로 계산한다. 각 부분문제의 답이 나오면 이를 이용하여
전체 문제의 답을 계산한다. 재귀 호출과 유사하나 하나의 재귀함수를 찾는 대신 여러 부분문제(거의 절반 정도의)로 분해한다는 점이 다르다.

조건 
1. 문제를 부분문제로 나눌 수 있는 자연스러운 방법이 있다.
2. 부분문제의 답들로 전체문제의 답을 계산하는 효율적인 방법이 있다.

주의점
잘못 분할할 경우 전체 과정에서 여러번 중복계산되는 부분 문제들이 나올 수 있다. 이는 전체 성능을 저하시킨다.
이 경우 Dynamic programming을 사용한다.

Dynamic Programming
---------------
중복계산되는 부분문제는 분할정복을 할 때 부분문제를 계산할 때 나타나는 중복되어 계산되는 부분문제이다. 중복계산되는 부분문제는 분할의 횟수가 늘어날수록 지수적으로 증가한다. 
대표적인 문제로 이항계수 계산이 있다.
DP는 분할정복과 비슷한 패러다임이지만 중복계산되는 부분문제(Overlapping subproblems)를 메모리에 저장해서 중복계산에 드는계산자원을 줄이는 방법이다.
(계산량이 줄어드는 대신 메모리 사용량이 늘어난다) 
이렇게 값을 저장해뒀다 재사용하는 방법을 memoization이라고 부른다. memoization은 입력에만 출력이 결정되는 referential transparent function에만 적용할 수 있다. 
입력 외의 요소가 결과에 영향을 주는 함수는 사용할 수 없다.
DP는 최적화 문제를 풀기위해 제안되었다. 최적화문제에서 유용하게 쓸 수 있다.(다른 문제들에서도 일부 유용하게 쓸 수 있음)

최적 부분 구조(optimal substructure)
현재 부분 문제가 어떤 경로로 호출되었던간에 남은 부분 문제들을 항상 최적으로 풀어도 되는 구조.
각 부분문제의 최적해를 얻었을 때 전체 문제의 최적해를 얻을 수 있을 경우 성립.
ex) 서울부터 대전을 지나 부산까지 가는 최적 경로 = 서울-대전의 최적경로 + 대전-부산의 최적 경로

최적화 문제의 DP 설계
1. 가장 간단한 해법인, 모든 답을 만들고 그 중 전체 점수가 가장 높은 최적해를 반환하는 부분문제 기반 exhaustive search 알고리즘을 설계
2. 전체 점수만 반환하는게 아니라 앞으로 남은 선택들의 점수를 반환하도록 부분문제 정의를 변경
3. 재귀 호출 입력에 이전 선택과 관련된 정보가 있다면 가능한 제거(독립적으로 만들기). 최적부분구조라면 완전 제거 가능.
    목적은 가능한한 중복되는 부분문제를 많이 만드는 것으로 중복된 문제가 많을수록 memoization을 효율적으로 할 수 있음.
4. 입력이 배열이나 문자열일 경우 가능하다면 memoization을 효율적으로 할 수 있도록 구조 변환(stl map등의 연관배열로 할 수 있으나 매우 느림)
5. memoization을 적용하여 1의 문제를 최적화.

경우의 수 계산하기 DP 설계
1. 모든 답을 직접 만들고 세어보는 exhaustive search 알고리즘 설계.
    a)모든 경우는 이 선택지들에 포함되어야 함
    b)어떤 경우도 두개 이상의 선택지에 포함되지 않음
2. 이전 조각에서 결정한 요소들에 대한 입력올 가능한 제거. 재귀 함수가 앞으로 남아있는 조각들을 고르는 경우의 수만 반환하도록 
3. memoization을 적용하여 최적화.

Greedy Method
---------------
위의 방법들과 마찬가지로 원하는 답을 재귀호출처럼 여러 조각으로 쪼갠 후 각 단계의 답을 이용해 전체 답을 구한다는 아이디어를 가진다.
exhaustive search나 DP와 다를 것이 없어보인다.. 하지만 모든 선택지를 전부 고려한 후 그 중 가장 좋은것을 고르는 두 방법과 달리
greedy method는 매 단계마다 해당 단계에서 가장 좋은 방법을 선택하는 알고리즘들을 말한다.

즉 현재 선택이 앞으로 남은 장기적인 선택들에 끼칠 영향을 고려하지 않는다. 
당연히 최적의 해를 찾을 가능성은 낮다. 
하지만 
1. greedy method를 사용해도 최적의 해를 찾을 수 있는 문제
2. 최적의 해를 찾기 너무 어려워 근사해를 찾는것만으로 의미가 있는 문제
에서 유용하게 사용할 수 있다. (인공신경망 학습의 gradient descent 방법이 greedy method에 속한다)

1에 해당하는 문제는 DP로도 풀 수 있으나 greedy method는 메모리나 계산시간에서 이점을 가진다.
2에 해당하는 문제는 조합탐색이나 메타휴리스틱 알고리즘들로 더 좋은 답을 구할 수 있다.

greedy method로 문제를 풀 수 있는것은 두가지 속성을 증명하면 된다.
greedy choice property. 이 속성이 성립할경우 매 순간의 greedy 선택은 최적해로 가는 선택이다.
optimal substructure 부문문제의 최적해에서 전체 문제의 최적해를 구할 수 있음을 보인다.

greedy method 설계
1. 문제의 답을 만드는 과정을 여러 부분문제로 나눈다.
2. 각 부분문제가 어떤 우선순위로 답을 내는지 결정한다. (직접 문제를 손으로 풀어보면 좋다)
3. 2가 결정되면, greedy method의 두 속성을 증명해본다.
    a) greedy choice property 각 단계에서 우리가 선택한 답을 포함하는 최적해가 존재하는가?
    우리의 답과 다른 최적해가 존재한다고 가정하고 이것을 조작하여 우리가 선택한 답을 포함하는 최적해로 바꿀수있는지 확인
    b) optimal substructure. 각 단계에서 최적의 선택만 했을 때 전체 최적해를 구할 수 있는지 증명
    
사용하기 좋은 문제 : 스케쥴링 문제 


Combinatorial Search
------------
그 동안의 방법들은 분할 방법이 없거나, 중복되는 부분문제가 없는 경우 적용할 수 없다.
이 경우 다시 exhaustive search로 돌아와야 한다. 
exhaustive search는 답을 내는 과정을 여러 선택으로 나누고 재귀호출로 각각의 선택지를 채워나가는 방법을 사용한다.
이때 부분답과 완성된 답의 집합을 search space라고 부른다. 
exhaustive search는 모든 답을 다 만들어보면서 문제를 해결한다. 따라서 수행시간은 search space의 크기에 비례한다.
하지만 대부분의 문제에서 search space의 크기는 문제 규모에 따라 기하급수적으로 증가한다.

유한한 크기의 탐색공간을 뒤지면서 답을 찾아내는 알고리즘들을 combinatorial search라고 한다(exhaustive search 포함)
이를 최적화하는 방법들은 기본적으로 최적해가 될 가능성이 없는 답들이 탐색되는것을 방지하여
seach space에서 탐색할 답의 수를 줄이는 것을 목표로 한다.
조합탐색은 문제 자체에 대한 식견, 속도와 정확도 사이의 trade off, 다양한 입력 형태 사이의 trade off를 모두 고려해야하며
어려운 문제에 속한다. 이렇다 할 정답이 없기에 모든 주제를 다룰 수는 없고 가장 유명한 접근법들, 처음으로 시도해보기 좋은
기법들에 대해 논의한다.

논의할 combinatorial search의 최적화 기법을 크게 두 가지로 분류한다.
pruning : 탐색 과정에서 최적해로 연결될 가능성이 없는 부분들을 가지치기한다. 예를들어 현재 상태에서 나머지 답을 완성해도 현 시점에서 가지고 있는 최적해보다 나쁘다면 탐색을 중지할 수 있다.
greedy search : greedy method를 이용해 적당히 좋은 답을 먼저 찾아내어 pruning과 함께 사용할 경우 탐색의 효율을 높일 수 있다.

heuristic : 경험적으로 어림짐작 하는 것. 특정한 조건을 찾아내어 탐색종료 조건으로 활용할 수 있지만 말 그대로 경험적이기에 답이 있다기보단 문제를 보고 유추해야함.

정수 계획법 <- 참고만

Decision Problem
----------
Optimization problem을 decision problem(yes or no 형태의 답만 나오는 문제) 형태로 바꾼 후 이분법을 이용해 해결하는 방법.
특정문제에서 decision problem이 optimization problem보다 훨씬 풀기 쉬운 경우 유용.(반대는 불가능)


Numerical Analysis
------------



Partial Sum
------------
0부터 현재 주소까지의 값을 더한 값을 저장해두고(memoization) 이를 이용해 a~b까지의 합을 쉽게 구할 수 있다.
2차원 배열에도 사용할 수 있고 2차원 배열값이 이미지일 경우 integral image라고 함.

Queue, Stack, Dequeue
------------
online algorithm : 전체입력이 한번에 주어지지 않고 일부만 계속해서 주어질 때 계산을 할 수 있는 알고리즘. 입력의 크기가 굉장히 클 때 유용.

Strings
------------
KMP algorithm : 문자열 검색문제를 위한 간단한 알고리즘
    부분 일치 테이블 (needle[:n]까지의 접미사이면서 접두사가 될 수 있는 최대 문자열의 길이를 반환)
suffix array : 문자열 처리를 위한 자료구조
<-- 다시보기

Tree
-----------
트리는 계층관계를 갖는 객체를 표현하기 위해 쓰이지만, 실제로는 계층관계와 상관없이 같은 연산을 더 빠르게 할 수 있는
경우에 유용하게 사용할 수 있다.
-일반적인 트리
    트리의 용도 
    1)계층관계를 갖는 객체 표현 : 눈에 보이는 계층관계가 아니더라도 따져보았을 때 계층 형태를 띄는 문제도 있다.
    2)탐색형 자료구조
    
    트리의 성질
    재귀적 속성 - 트레에서 한 노드와 그 자손들은 또 하나의 트리이다.(sub tree) 따라서 재귀 호출로 구현한다.
    
    트리의 순회
    트리는 구조가 일정하지 않아 모든 자료를 순회하는 것이 어렵다. 이를 쉽게 하기 위해 재귀적인 속성을 이용한다.
    크게 3가지 방법이 있으며 preorder traverse(root-left-right), inorder traverse(left-root-right), postorder traverse(left-right-root)이다.
    
  
-트리에서 가장 긴 path 찾기 
    hint : 가장 긴 path의 양 끝 노드는 항상 leaf or root 노드이다.
       
-이진 검색 트리(탐색형 자료형). 
    이진트리(자식이 두개)이며 자료가 크기 순서로 정렬되어있어 추가,삭제,존재 여부 등의 연산을 배열보다 훨씬 빠르게 수행가능.
    크기 순서로 정렬된 배열과 차이점은 선형 자료구조가 아니기에 삽입이 수월하다는 것이다.
    삭제는 삭제하려는 노드의 두 자식을 각각 루트로 하는 두 서브트리를 합친(merge) 후 해당 트리의 루트를 삭제하려는 노드와 바꾼다.
-skewed tree
    예를 들어 root가 1이고 1~100까지 주어지는 이진 탐색 트리는 사실상 연결리스트가 되어 이진탐색트리로 사용하는 의미가 없다.
    이런 경우에도 제대로 기능할 수 있도록 balance를 잡아주는 변종들도 있으며 대표적으로 red black tree가 있다.
    
-트립(이진 검색 트리의 변종)
    트리에서 x보다 작은 원소의 수 찾기, k번째 원소 찾기 연산 등은 표준 라이브러리들에서 지원하지 않는 경우가 많다.
    이런 경우 이진 검색트리를 직접 구현해야하는데 단순한 이진 검색 트리는 skewed 문제로부터 자유롭지 않다.
    교과서적인 balanced tree인 AVL 트리나 red black 트리는 구현이 매우 까다로우며 어렵다.
    따라서 구현이 간단한 balanced tree인 treap이 유용하게 쓰일 수 있다.
    트리에 노드를 추가 할 때 임의의 priority를 부여한 후, 부모의 priority가 항상 자식의 priority보다
    크거나 같다는 조건을 조건을 추가한다. 즉 treap은 이진탐색트리의 조건과 함께 heap의 조건을 동시에 만족하도록 구성된다.(tree + heap이라서 treap이다.)
    쉽게 이해하려면 입력 순서대로 트리에 추가하는것이 아니라 우선순위를 먼저 매긴 후 우선순위로 정렬하여 높은것부터 트리에 추가한것이라고 이해하면 된다.
    (아주 낮은 확률로 skewed가 등장할 수도 있다.)
    treap의 삽입연산은 재귀호출을 통해 하면 되지만 새로운 노드의 priority가 root보다 높을 경우 새로운 root가 되어야 하기 때문에 조금 복잡해진다.
    기존 root의 key값이 새로운 노드보다 클 경우와 작을 경우로 나뉘는데, 방법은 비슷하다.
    만약 작다면, 기존 tree에서 root의 오른쪽 자손을 root로 하는 sub tree를 떼어낸다.
    그리고 이 sub tree를 추가된 노드의 key값과 비교하여 큰 것과 작은 것 두 sub tree로 분리한다.
    값이 작은 sub tree를 기존 root의 오른쪽 자손으로 연결하고, 값이 큰 sub tree는 추가된 노드의 오른쪽 자손으로 연결한다.
    그리고 기존 root를 추가된 노드의 왼쪽 자손으로 연결한다. 
    노드 삭제는 이진 탐색트리와 유사하다.
    treap을 직접만들어야하는 경우는 표준 라이브러리 구현에서 제공하지 않는 기능들(k번째 원소 찾기, x보다 작은 원소의 개수 세기 등)이 필요할 때 뿐이다.
    따라서 treap을 만들 때 각 노드 클래스는 서브트리의 크기 size등을 추가하여 만들게 된다. 
    
-우선순위 큐
    일반적인 큐와 비슷하지만 priority가 높은 자료가 먼저 pop되는 큐.
    수행할 작업이 여럿 있는데 시간은 제한되어 있을 때 우선순위가 높은 것부터 수행하는 경우에 사용하며 현실에서 종종 필요한 구조이다.
    balanced binary search tree로도 가능하지만 해야할 작업에 비해서 너무 복잡하다.
    우선순위 큐는 이러한 작업을 더 단순하게 수행할 수 있으며 대표적인 것이 heap tree이다.
    
    
-힙 
    heap은 최대,최소값을 root로 하도록 유지하는 조건이 걸린 트리로 최대 최소값을 찾는데 특화되어있다.
    우선순위 큐는 heap을 이용하면 아주 쉽게 구현할 수 있는데 heap의 최대값 조건을 priorty로 하여 구현하면 된다.
    heap은 이진트리와 달리 부모 노드가 자식 노드보다 큰 값을 가지기만 하면 되고 좌우의 대소관계는 신경쓰지 않는다.
    대신 skewed 될 경우 트리의 장점을 잃는다는 것은 똑같기 때문에 두가지 모양 규칙을 부여하여 만든다.
    1) 마지막 레벨을 제외한 모든 레벨에 노드가 꽉 차있어야 함
    2) 마지막 레벨에 노드가 있을 경우에는 항상 가장 왼쪽부터 순서대로 채워나가야 함.
    힙의 이런 조건들 덕분에 힙을 구현할 때 동적 배열로 트리를 표현할 수 있게 된다.(index를 이용해 부모자식관계등을 쉽게 찾을 수 있음)
    동적배열을 사용한 heap을 구현하였을 때 어떻게 새 원소를 꺼낼 수 있을까?
    특히 root를 제거할 경우 heap의 조건을 만족시키는 새로운 heap tree를 만드는 것은 까다롭다.
    이 경우 제거된 root node 자리에 맨 마지막 노드를 보내서 우선 모양 규칙을 만족시키고 대소규칙을 따르도록 자식노드들과
    자리를 바꾸어가는 재귀호출을 사용한다.
    배열을 정렬할때 자료를 heap으로 만들고 root부터 pop하면 정렬된 순서대로 출력되기 때문에 heap sort가 된다.
    pop되면 heap의 배열에 한자리가 비는데 여기에 pop된 자료를 넣으면 메모리 낭비도 없으며 최악의 경우에도 O(NlogN)만 사용한다.
    
    
-구간 트리
    segment tree는 저장된 자료를 구간별로 전처리하여 구간에 대한 질의에 빠르게 대답할 수 있게 만든 자료구조이다.
    흔히 일차원 배열에서 특정 구간에 대한 질문을 빠르게 대답하는데 쓸 수 있다.
    대표적인 예시로 특정 배열이 주어질 때 배열의 부분 구간의 최소치를 구하는 문제가 있다.
    이런 문제는 배열을 binary tree에 넣고(각 절반의 범위) 각 노드마다 해당하는 구간의 최소치를 넣어둔다.
    그리고 특정 구간이 주어졌을 때 주어진 구간은 노드로 표현된 범위의 합집합으로 표현할 수 있게 되는데 포함되는 노드에 저장된
    최소치들을 비교하여 가장 작은 값을 출력하면 된다. 이를 구간 최소 트리(range minimum query RMQ)라고 한다.
    꽉 찬 이진트리는 heap처럼 배열에 저장하여 메모리를 절약할 수 있다.
    구간트리는 약간의 값이 바뀔 때는 처음부터 새로 만들지 않고도 업데이트가 가능하다.
    구간별로 최소값이 아니라 값의 출현 빈도 등 다른 질의일 경우 이를 풀 수 있도록 필요한 추가정보들도 반환할 수 있도록 해야한다.
    최소 공통 조상 문제(lowest common ancestor) 예를들면, 촌수 찾기 문제.
    최소 공통 노드는 두 노드가 주어질 때 두 노드를 모두 자손으로 가지는 노드 중 가장 아래 있는 노드이다.
    
    
-펜윅 트리
    segment tree 중 구간 합을 구하기 쉽도록 만든 트리로, binary indexed tree라고도 한다.
    개념이 조금 복잡하지만 구현은 상대적으로 간단하다.
    <- 다시보기 
    
-유니온 파인드 자료구조(집합을 트리로 표현)
    공통원소가 없는 disjoint set을 표현할 때 쓰는 자료구조.
    disjointed set은 한 원소가 여러 집합에 속할 수 없다.
    이런 set을 표현하기 위해 3가지 연산이 필요한데, 초기화, 합치기(union), 찾기(find)중 union과 find를 이용해 union-find 자료구조라고 부른다.
    union은 초기화된 상태에서 공통된 집합에 속한 원소를 집합으로 묶는 연산이며
    find연산은 묶인 집합들에 대해 원소가 주어졌을 때 해당 원소가 속한 집합을 반환한다.
    union-find 자료구조를 트리로 표현하기 위해 각 집합을 트리로 표현한다. 그리고 루트 노드는 자기 자신을 루트로 가지도록 구현한다.
    (부모에서 자식으로 갈 일은 없기 때문에 해당 포인터를 구현할 필요는 없다.)
    루트는 대표 노드라고 부르며, 그냥 임의의 원소를 루트로 둔다고 생각하자.
    특정 원소를 다른 집합으로 합칠 경우 특정 원소의 루트를 찾아 그 루트를 합치고자 하는 다른 트리의 루트에 자식으로 한다.
    skewed 문제를 막기 위해 두 트리를 합칠 때 단순하게 높이가 낮은 트리를 높이가 높은 트리의 자식으로 두도록 구현한다.(union by rank 최적화)
    특정 노드의 root를 찾는 연산이 중복되기 때문에 parent 변수를 만들고 root를 찾았을 때 이를 갱신한다(path compression 최적화)
    disjoint set으로 풀 수 있는 문제는 대부분 그래프나 다른 자료구조로도 풀 수 있으나
    구현이 매우 간단하며 동작 속도가 아주 빨라 다른 알고리즘에 섞어 쓸 수 있다.
    ex ) 그래프 연결설 확인 문제, 가장 큰 집합 추적하기 문제
    
-트라이(문자열을 표현하는 트리)
    문자열을 다루는 알고리즘은 정수나 실수같은 다른 자료형 다루는 것과 다르다.
    문자열변수의 비교는 최악의 경우 문자열의 길이에 비례하는 시간이 걸린다.
    그래서 정수나 실수에서 잘 동작하는 탐색 자료구조들도 문자열을 키로 사용할 시 너무 느릴 수 있다.
    이런 문제를 완화하기 위해 문자열 특화 자료 구조가 있으며 대표적으로 트라이(trie)가 있다.
    트라이는 문자열의 집합을 표현하는 트리 자료구조로 문자열 집합 내에서 원하는 원소를 찾는 탐색 작업을 O(M)만에 할 수 있다.
    트라이는 접두사들에 대응되는 노드들이 서로 연결된 트리이다.
    한 접두사 맨 뒤에 글자를 더해 다른 접두사를 얻을 수 있을 때, 두 노드는 부모 자식 관계로 연결된다.
    edge에 덧붙인 글자가 대응된다는 사실이 특이하다.
    트라이의 루트는 항상 길이가 0인 문자열에 대응된다. 노드의 깊이가 깊어질수록 대응되는 문자열의 길이는 1씩 늘어난다.
    완성된 글자는 종료 노드로, Be, Bet, tea가 있을 때 be는 bet의 부모이지만 종료노드이다. 따라서 항상 leaf노드가 종료 노드가 아님에 주의하자.
    트라이는 루트부터 시작해서 특정 노드까지 내려가는 경로에서 만나는 글자를 모두 모으면 해당 노드에 해당하는 접두사를 얻을 수 있다.
    따라서 각 노드에 대응되는 문자열을 저장할 필요가 없다. 
    트라이의 한 노드는 자손 노드들을 가리키는 포인터목록과 노드가 종료노드인지 아닌지를 표현하는 boolean 변수로 이루어진다.
    포인터는 동적배열로 구현하지 않고 입력에 등장할 수 있는 가능한 모든 글자들에 대응되는 고정길이 배열로 구현한다.(메모리 낭비는 있지만 다음 노드를 찾을 때 
    탐색이 필요하지 않다. 없다면 null)
    트라이는 간단하고 탐색속도가 다른 어떤 자료구조보다 빠르다(검색엔진, 문자열 처리 프로그램에서 유용)
    트라이의 문제점은 필요로 하는 공간이 너무 크다는 것이다. 이를 최적화하는 방법들도 있지만 복잡하고 작성하는데 오래 걸려 대회등에서는 문자열의 개수가 적을 경우에만 사용한다.
    
    트라이는 집합에 포함된 문자열을 찾을 때 유용하지만, 트라이를 이용해 다중 문자열 검색도 수행할 수 있다. 접두사가 같은 노드에 대응된다는 점을 이용하여 탐색공간을 줄일 수 있다.
    KMP알고리즘(실패함수를 사용하는 방법)과 트라이를 이용하여 실패함수 f(s)를 s의 접미사이면서 트라이에 포함된 가장 긴 문자열까지가는 포인터 로 재정의할 수 있다.
    이 알고리즘을 아호-코라식 문자열 검색 알고리즘이라고 한다.
    아호 코라식 알고리즘을 위해 각 노드마다 추가적인 정보 두가지를 포함해야한다.
    1) failure link : 이 노드에서 다음 글자 대응이 실패했을 때 그 다음으로 가서 검색을 재개해야 할 노드의 포인터
    2) 출력 문자열 목록 
    <- 다시보기
    
그래프
    그래프는 객체들의 상호관계를 표현하기 위해 고안된 자료구조로, 계층구조에 특화된 트리에 비해 더 다양한 문제들을 표현할 수 있다.
    
그래프 기초
    선형자료구조 - > 계층구조를 위한 트리 -> 상호관계를 위한 그래프
    그래프는 정점과 간선으로 구성된다. 
    기본 구조는 간단하지만 정점이나 간선에 추가적인 속성을 부여하거나, 형태의 제약을 두기도 한다.
    대표적으로 directed graph가 있으며 방향이라는 속성을 추가하여 특정 간선이 한쪽 방향으로만 동작하게 한 것이다.
    weighted graph는 각 간선에 가중치가 주어지는 그래프이다.
    multigraph는 두 정점 사이에 두 개 이상의 간선이 있을 수 있는 그래프를 말한다.<-> simple graph
    bipartite graph는 각 정점들이 겹치지 않는 두개의 그룹으로 나뉘고, 각 그룹 간에만 간선이 존재할 수 있는 그래프이다.
    DAG(directed acyclic graph) 자기자신으로 돌아오는 사이클이 없는 방향성 그래프.
    
그래프의 경로
    path. 경로란 끝과 끝에 해당하는 정점들이 주어질 때 서로 연결된 간선들을 순서대로 나열한 것이다. 
    simple path: 경로 중 한 정점을 최대 한번씩만 지나는 경로. 그냥 path라고 해도 보통 simple path를 의미하는 경우가 많다.
    cycle : 경로 중 시작한 정점으로 끝나는 경로를 cycle이라고 한다.
implicit graph 
    그래프 형태가 아니더라도 그래프를 통해 표현하면 쉽게 표현할 수 있는 구조.
    ex 할일 목록. 의존관계에 있는 객체들을 한번에 하나씩 어떤 순서대로 해나갈지 결정하는 문제 : 위상정렬로 푼다.
    15-퍼즐. 4x4 칸 위에서 타일들을 움직여 원래 순서대로 정렬하는 퍼즐. 4x4 상태 하나를 정점으로, 하나의 위치를 변경하는 것을 간선으로 하여 정답과 현재 상태 사이의 최단경로를 구하는 문제로 치환.
    게임판 덮기. NxN 게임판 위에 1x2 사이즈의 블록으로 모두 덮는 문제. 이분 그래프로 풀 수 있다.
    회의실 배정. N개의 팀이 회의를 하려 하는데 회의실이 하나 뿐일 경우, 한번에 한팀만 사용할 수 있다. 각 팀이 회의실을 사용하고자 하는 시간을 2개씩 적어 냈다. 각 팀의 시간 중
    한개씩을 선택하여 모든 팀이 회의할 수 있도록 할 수 있을까? 만족성 문제(satisfiability problem. SAT). 두 선택지를 내기 때문에 2-SAT라고 한다. 이를 그래프의 강 결합성 문제로 풀 수 있다.
    
그래프의 표현
    트리처럼 표현할 수 있지만, 그래프는 보통 정적인 용도로 사용된다.
    정적이라는 것은 새로운 정점이나 간선을 추가하거나 삭제하는 경우가 자주 일어나지 않는다는 뜻이다.
    이미 주어진 그래프 안에서 경로에 대한 연산을 하는 경우가 훨씬 많다.
    따라서 대부분 그래프는 구조를 변경하기 좀 어렵더라도 간단하고 메모리를 적게 차지하는 방법으로 표현한다.
    이 방법은 각 정점에 0~N의 번호를 메기고, 배열에 각 정점의 정보를 저장하는 것이다.
    각 간선은 반대쪽 끝 정점 객체의 포인터를 저장하는 대신 반대쪽 정점의 번호(배열 index)를 저장하는 식으로 구현한다.
    이런 표현 방식은 간선의 정보를 어떤 식으로 저장하느냐에 따라 두가지로 나뉜다.
    메모리나 시간 사용 특성이 많이 달라 프로그램 성능에 큰 영향을 끼치니 주의깊게 선택해야 한다.
        1)인접리스트의 표현
    adjacency list는 그래프의 각 정점마다 해당 정점에서 나가는 간선의 목록들을 저장하여 그래프를 표현한다.
    각 정점마다 하나의 연결리스트를 가지는 방식으로 구현된다.(이 리스트에 실제로 추가 삭제를 할 일은 많이 없으니 벡터 리스트 대신 동적배열을 사용해도 된다.)
    adjacency list는 해당하는 정점과 연결되어있는 정점들의 번호를 저장하고 있다. 
    추가적인 정보(weight라던지..)도 함께 저장해야한다면 구조체나 dictionary등으로 저장할 수 있다.
        2)인접 행렬의 표현
    인접리스트 표현의 단점은 두 정점이 주어질 때 두 정점이 연결되어있는지 여부를 확인하려 할 때, 연결리스트를 일일이 뒤져야한다는 것이다.
    이 연산의 속도를 줄이기위해 고안된 그래프 표현 방식이 adjacency matrix라고 한다. 
    이름에서 유추할 수 있듯, adjacency matrix는 VxV 크기의 행렬을 이용하여 그래프의 간선정보를 저장한다.
    가장 간단한 형태는 불리언 배열이지만 weight등이 있다면 weight값을 이용하여 저장하거나 할 수 있다. 간선이 없는 경우 0,-1, 아주 크거나 작은 값등을 사용할 수 있다.
        두 표현의 비교
    두 표현 방식은 서로 장단점이 반대이다. 따라서 알고리즘의 종류나 그래프의 종류에 따라 적절히 선택해야 한다.
    인접행렬의 장점은 두 정점이 주어졌을 때, 그 사이에 간선이 있는지를 한번의 배열 접근만으로 확인할 수 있다는 것이다.
    인접행렬의 단점은 실제 간선의 개수와 관계없이 항상 $V^{2}$크기의 공간을 사용한다는 문제점이 있다.
    인접 리스트의 장점은 V+E의 공간만을 사용한다는 것이며, 간선의 수가 적은 sparse graph를 다루면서 메모리가 한정적일 경우 유용하다.
    인접 리스트의 단점은 두 정점이 연결되어있는지 여부를 확인할 때 연결리스트를 순회해야한다는 것이다.
    
암시적 그래프의 표현
    그래프개념을 이용해 푸는 문제라고 해도 항상 그래프를 직접 메모리에 표현할 필요는 없다.
    입력이 그래프의 형태를 띄지 않는다면 그래프 구조로 표현하지 않고도 알고리즘들을 적용할 수 있다.
    미로에서 최단경로 찾기 문제의 경우가 대표적인데, 모든 열린 칸을 정점으로, 인접된 칸들을 서로 간선연결한 후 너비 우선 탐색을 통해 쉽게 풀 수 있으나,
    입력을 일일이 그래프로 표현하는 것이 번거롭다.
    이 경우 그냥 빈 칸의 위치 좌표로 표현하고 간선을 탐색하는 대신 좌표의 상하좌우를 탐색할 경우 그래프로 표현하지 않아도 너비 우선 탐색을 이용할 수 있다.
    암시적 그래프 표현이 유용한 또 다른 예는 그래프의 크기는 아주 큰데 실제로는 그 중의 일부만 사용하는 경우이다.
    예를 들어 15-퍼즐의 경우, 가능한 상태의 경우의 수는 16!로 약 20조개인데, 현재 상태와 정답 상태의 사이를 연결하는 최단경로는 이 중 극히 일부만 방문하기 마련이다.
    따라서 암시적 그래프 표현으로 그래프 전체를 메모리에 올리지 않고도 문제를 풀 수 있다.
    암시적 그래프의 표현의 단점은 그래프를 사용하는 알고리즘과 변환 과정이 결합되어 코드가 더 복잡해지기마련이다. 
    따라서 그래프에 대해 복잡한 연산이나 알고리즘을 적용할 계획이라면 조금 번거롭더라도 입력을 미리 그래프 표현으로 바꿔두는 것이 코드를 간결하게 만들어준다.
    
        
그래프의 탐색
    트리의 순회와 같이 그패으의 모든 정점을 특정한 순서에 따라 방문하는 알고리즘들을 그래프 탐색(search)라고 한다.
    트리의 순회는 트리에 있는 모든 정점들을 확인할 때가 아니라면 큰 의미가 없었으나 그래프는 트리보다 구조가 훨씬 복잡하여 탐색과정에서 얻을 수 있는 정보들이 아주 중요하다.
    탐색은 흔히 그래프 전체의 구조를 파악하기 위해 사용된다.
    탐색 과정에서 어떤 간선들을 사용하였는지, 또 어떤 순서대로 정점들이 방문되어있는지를 통해 그래프의 구조를 알 수 있다.
    탐색 알고리즘 중 가장 널리 사용되는 두가지는 깊이 우선 탐색(Depth first search)와 너비 우선 탐색(Breadth first search)이 있다.
     
깊이 우선 탐색 DFS
    DFS는 그래프의 모든 정점을 발견하는 가장 단순하고 고정적인 방법이다. 현재 정점과 인접한 간선들을 하나씩 검색하다가 아직 방문하지 않은 정점으로 향하는 간선을 찾으면 무조건 그 간선을 따라간다.
    이 과정에서 더이상 갈 곳이 없는 정점에 도달하면 마지막에 따라왔던 간선을 따라 뒤로 돌아오는 방법으로 동작한다.
    뒤로 돌아오는 것은 재귀함수를 이용하면 쉽게 구현할 수 있다. 재귀함수는 호출이 끝나면 원래 진행되던 순서로 돌아가기 때문이다.
    DFS는 연결된 모든 정점을 방문하지만 그래프가 연결되지 않고 두개 이상으로 분리되어 표현된 경우에는 모든 정점을 방문할 수 없다. 따라서 모든 정점을 순회하면서 방문되지 않은 경우 dfs를 수행하는 함수를 추가해준다.
    dfs의 시간복잡도는 인접 리스트를 썼을 경우 O(V+E), 인접 행렬을 썼을 경우 O($V^{2}$)이다.
    깊이 우선 탐색을 이용하면 두 정점 사이를 잇는 경로가 있는지 쉽게 확인할 수 있다. 어떤 정점 u에 대해 dfs(u)를 호출하고 visited[]변수를 만들어 u로부터 각 정점에 갈 수 있는지를 쉽게 찾을 수 있다.
    분리된 그래프의 경우, 전체 그래프에서 서로 연결되지 않고 자기들끼리 연결되어있는 서브 그래프를 컴포넌트라고 하는데, 그래프 내에서 컴포넌트가 몇개 있는지 파악하는 것이 기초적인 그래프 문제 중 하나이다.
    이 경우도 dfs를 이용하여 풀 수 있며, dfsall 함수가 dfs를 몇번 호출했는지를 세면 쉽게 확인할 수 있다.

위상 정렬
    위상정렬 문제는 dfs로 풀 수 있는 유명한 문제 중 하나로, 의존성이 있는 작업들이 주어질 때 이를 어떤 순서로 수행해야하는지 계산하는 문제이다.
    대표적으로 레시피 문제가 있는데, 레시피중 일부 작업은 사전에 다른 작업을 수행해두어야만 수행될 수 있다.(돼지고기 굽기 작업A는 돼지고기 자르기B 이후에 올 수 있다. 이 경우 작업 A가 작업 B에 의존한다고 한다.)
    각 작업을 정점으로, 의존성을 방향성 간선으로 표현한 방향성 그래프를 의존성 그래프라고 한다.
    의존성 그래프의 가장 큰 특징은 사이클이 없다는 것으로, DAG가 된다. 
    의존성 그래프의 모든 정점을 일렬로 늘어놓고 왼쪽부터 하나씩 수행한다고 가정할 때, 모든 의존성이 정상적으로 만족되려면 모든 간선이 왼쪽에서 오른쪽으로 향해야만 한다.
    이렇게 DAG 정점들을 배열하는 문제를 위상정렬 문제라고 한다.
    위상정렬을 가장 간단하게 구현하는 방법은 들어오는 간선들이 하나도 없는 작업들을 하나씩 찾아서 정렬 결과의 뒤에 붙이고, 그래프에서 이 정점을 지우는 것을 반복하는 것이다.
    하지만 dfs를 이용하면 이를 더 간단하게 풀 수 있다. 의존성 그래프에 dfsall()을 수행하고 dfs가 중료할때마다 현재 정점의 번호를 기록하는것이다.
    dfsall()이 종료한 후 기록된 순서를 뒤집으면 위상정렬 결과를 얻을 수 있다.
    
오일러 경로
    그래프의 모든 간선을 정확히 한번씩 지나서 시작점으로 돌아오는 경로 찾기(오일러 서킷!)
    그래프 이론에서 첫번째로 연구된 문제로 유명. 한붓 그리기 문제.
    유향, 무향 그래프에서 모두 풀 수 있으나 무향 그래프를 가정한다.
    
    
너비 우선 탐색 BFS(가중치가 없는 그래프의 최단경로 문제)
가중치가 있는 그래프의 정점 사이 최단경로 문제
최소 스패닝 트리 문제
간선의 용량을 고려한 그래프의 최대 유량 문제

    
    
    
    
     