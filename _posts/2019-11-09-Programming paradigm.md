---
layout: post
title: Programming Paradigm
categories : [ML,DL]
use_math: true
---
Prgramming Paradigm
================
by 알고리즘 문제 해결 전략

1. 단순한 문제로 만들고 최적화 시켜 나간다.

Type of Problems 
------------
- 원하는 답이 존재하는가?
- 여러 답 중 최적의 답 찾기(최적화 문제)


Brute Force
----------------   
완전 탐색 exhaustive search 라고도 한다. 가장 단순한 방법. 모든 경우의 수를 직접 컴퓨터로 돌려보고 그 결과를 찾는 방법이다.
무식해보이지만 컴퓨터는 반복연산에 강점이 있어 별다른 제약이 없는 경우 이 방법으로 대부분의 문제를 풀 수 있다.
실제 상업용 프로그램이나 대회에서는 메모리, 연산량, 연산시간 등에서 제한이 있는 경우가 많지만
제한이 미미한 경우 그냥 사용하기도 한다.
장점은 쉽고 단순하다는 것. 제약조건을 잘 따져본 후 가능하다면 brute force 방법을 쓴다면 많은 노력을 아낄 수 있다.
재귀호출으로 쉽게 구현할 수 있는 경우가 많다.

Divide & Conquer
---------------
분할정복. 주어진 문제를 둘 이상의 부분문제로 분해한 후 각 부분문제를 재귀호출로 계산한다. 각 부분문제의 답이 나오면 이를 이용하여
전체 문제의 답을 계산한다. 재귀 호출과 유사하나 하나의 재귀함수를 찾는 대신 여러 부분문제(거의 절반 정도의)로 분해한다는 점이 다르다.

조건 
1. 문제를 부분문제로 나눌 수 있는 자연스러운 방법이 있다.
2. 부분문제의 답들로 전체문제의 답을 계산하는 효율적인 방법이 있다.

주의점
잘못 분할할 경우 전체 과정에서 여러번 중복계산되는 부분 문제들이 나올 수 있다. 이는 전체 성능을 저하시킨다.
이 경우 Dynamic programming을 사용한다.

Dynamic Programming
---------------
중복계산되는 부분문제는 분할정복을 할 때 부분문제를 계산할 때 나타나는 중복되어 계산되는 부분문제이다. 중복계산되는 부분문제는 분할의 횟수가 늘어날수록 지수적으로 증가한다. 대표적인 문제로 이항계수 계산이 있다.
DP는 분할정복과 비슷한 패러다임이지만 중복계산되는 부분문제(Overlapping subproblems)를 메모리에 저장해서 중복계산에 드는계산자원을 줄이는 방법이다.(계산량이 줄어드는 대신 메모리 사용량이 늘어난다) 
이렇게 값을 저장해뒀다 재사용하는 방법을 memoization이라고 부른다. memoization은 입력에만 출력이 결정되는 referential transparent function에만 적용할 수 있다. 입력 외의 요소가 결과에 영향을 주는 함수는 사용할 수 없다.
DP는 최적화 문제를 풀기위해 제안되었다. 최적화문제에서 유용하게 쓸 수 있다.(다른 문제들에서도 일부 유용하게 쓸 수 있음)

최적 부분 구조(optimal substructure)
현재 부분 문제가 어떤 경로로 호출되었던간에 남은 부분 문제들을 항상 최적으로 풀어도 되는 구조.
각 부분문제의 최적해를 얻었을 때 전체 문제의 최적해를 얻을 수 있을 경우 성립.
ex) 서울부터 대전을 지나 부산까지 가는 최적 경로 = 서울-대전의 최적경로 + 대전-부산의 최적 경로

최적화 문제의 DP 설계
1. 가장 간단한 해법인, 모든 답을 만들고 그 중 전체 점수가 가장 높은 최적해를 반환하는 부분문제 기반 exhaustive search 알고리즘을 설계
2. 전체 점수만 반환하는게 아니라 앞으로 남은 선택들의 점수를 반환하도록 부분문제 정의를 변경
3. 재귀 호출 입력에 이전 선택과 관련된 정보가 있다면 가능한 제거(독립적으로 만들기). 최적부분구조라면 완전 제거 가능.
    목적은 가능한한 중복되는 부분문제를 많이 만드는 것으로 중복된 문제가 많을수록 memoization을 효율적으로 할 수 있음.
4. 입력이 배열이나 문자열일 경우 가능하다면 memoization을 효율적으로 할 수 있도록 구조 변환(stl map등의 연관배열로 할 수 있으나 매우 느림)
5. memoization을 적용하여 1의 문제를 최적화.

경우의 수 계산하기 DP 설계
1. 모든 답을 직접 만들고 세어보는 exhaustive search 알고리즘 설계.
    a)모든 경우는 이 선택지들에 포함되어야 함
    b)어떤 경우도 두개 이상의 선택지에 포함되지 않음
2. 이전 조각에서 결정한 요소들에 대한 입력올 가능한 제거. 재귀 함수가 앞으로 남아있는 조각들을 고르는 경우의 수만 반환하도록 
3. memoization을 적용하여 최적화.

Greedy Method
---------------
위의 방법들과 마찬가지로 원하는 답을 재귀호출처럼 여러 조각으로 쪼갠 후 각 단계의 답을 이용해 전체 답을 구한다는 아이디어를 가진다.
exhaustive search나 DP와 다를 것이 없어보인다.. 하지만 모든 선택지를 전부 고려한 후 그 중 가장 좋은것을 고르는 두 방법과 달리
greedy method는 매 단계마다 해당 단계에서 가장 좋은 방법을 선택하는 알고리즘들을 말한다.

즉 현재 선택이 앞으로 남은 장기적인 선택들에 끼칠 영향을 고려하지 않는다. 
당연히 최적의 해를 찾을 가능성은 낮다. 
하지만 1. greedy method를 사용해도 최적의 해를 찾을 수 있는 문제
2. 최적의 해를 찾기 너무 어려워 근사해를 찾는것만으로 의미가 있는 문제
에서 유용하게 사용할 수 있다. (인공신경망 학습의 gradient descent 방법이 greedy method에 속한다)

1에 해당하는 문제는 DP로도 풀 수 있으나 greedy method는 메모리나 계산시간에서 이점을 가진다.
2에 해당하는 문제는 조합탐색이나 메타휴리스틱 알고리즘들로 더 좋은 답을 구할 수 있다.

greedy method로 문제를 풀 수 있는것은 두가지 속성을 증명하면 된다.
greedy choice property. 이 속성이 성립할경우 매 순간의 greedy 선택은 최적해로 가는 선택이다.
optimal substructure 부문문제의 최적해에서 전체 문제의 최적해를 구할 수 있음을 보인다.

greedy method 설계
1. 문제의 답을 만드는 과정을 여러 부분문제로 나눈다.
2. 각 부분문제가 어떤 우선순위로 답을 내는지 결정한다. (직접 문제를 손으로 풀어보면 좋다)
3. 2가 결정되면, greedy method의 두 속성을 증명해본다.
    a) greedy choice property 각 단계에서 우리가 선택한 답을 포함하는 최적해가 존재하는가?
    우리의 답과 다른 최적해가 존재한다고 가정하고 이것을 조작하여 우리가 선택한 답을 포함하는 최적해로 바꿀수있는지 확인
    b) optimal substructure. 각 단계에서 최적의 선택만 했을 때 전체 최적해를 구할 수 있는지 증명
    
사용하기 좋은 문제 : 스케쥴링 문제 